import * as f from './fun.js';
import {conform} from './conform.js';

const DEBUG = false;

const initVal = (shape) => ({"number": 0, "string": "", "boolean": false, "array": []})[shape];

const nullStore = () => ({r: () => null, shape: null});

const scalarStore = (shape, v) => {

    if(!conform(shape,v)) return null;
    
    let val = (v != null) ? JSON.parse(JSON.stringify(v)) : initVal(shape);

    const read = () => (val != null) ? val : initVal(shape);

    const save = (valOrFn) => {

	let value = valOrFn;

	if(typeof valOrFn == "function") value = valOrFn(val);

	val = (value != null) ? JSON.parse(JSON.stringify(value)) : initVal(shape);

    }

    const del = () => val = undefined;

    const vis = () => ["p", {class: "scalar " + typeof shape, style: {background: "rgba(0,0,0,0.0125)", border: "1px solid rgba(0,0,0,0.05)", padding: "1rem", display: "inline-flex", "align-items": "center", margin: "0.125rem", position: "relative"}}, val];

    return {r: read, d: del, s: save, v: vis};

};

const storeAtKey = (coll, k) => {
    
    let store = coll.store()[k];

    if(store == null) {

	DEBUG && console.error("No store at index: " + k + " in " + JSON.stringify(coll));

	return nullStore();
    }

    else return store;

};

const querySelector = (selection, query) => {

    if(selection.shape == null) return nullStore();

    if(typeof query == "string") return storeAtKey(selection, query);

    else if(typeof query == "number") return storeAtKey(selection, query);
    
    else if(typeof query == "function") {

	// Have to turn this into Object.entries when coll is a map
	let result = selection.r().filter(x => query(x));

	return arrayStore(selection.shape, result);
	
    } else if(f.isObj(query)) {

	// Which one uses this?
	return selection;
	
    } else if(query instanceof Array) {

	return arrayStore(selection.shape, query.map(q => querySelector(selection,q)));
	
    } else {

	console.error("Unknown query: " + query);

    }
    
};

const processQueries = (selection, queries) => {

    if(f.isEmpty(queries)) return selection;

    else {

	const [aQuery, ...others] = queries;

	let result = querySelector(selection, aQuery);
	
	return processQueries(result, others);

    };

};

const parseQueryString = queries => queries.reduce((i, q) => (typeof q == "string") ? i.concat(q.split("/")) : i.concat(q), []);

// queries : "string" | "string", fn 
const queryParser = (selection) => (...queries) => processQueries(selection, parseQueryString(queries));

// const saveWhere = (f, val) => arr = arr.reduce((i,n) => f(n) ? () => v : n, []);
// const updateWhere = (f, updateFn) => arr = arr.reduce((i,n) => f(n) ? updateFn(n) : n, []);
const arrayStore = (shape, vs) => {

    if(!conform([shape],vs)) return;

    let arr = vs ? vs.map(v => makeStore(shape, v)) : [];

    const read = () => arr.map(v => v.r());

    const save = (query, params) => {

	if(params == null) {

	    params = query;

	    query = null;
	    
	};

	if(query != null) {

	    if(query == "push") { push(params); }

	    if(query == "del") { del(params); }
	    
	} else {

	    if(typeof params == "function") params = params(read());
	    
	(arr = params.map(v => makeStore(shape, v)), read());

	}

    };

    const push = v => {
	
	let s = makeStore(shape, v);

	arr.push(s);

	return read();

    };

    const del = (idx) => {

	console.log("Splicing: ", idx);
	return (idx == null) ? (arr = undefined, read()) : (arr.splice(idx, 1), read()); 

    }

    const info = () => console.log("Array"+ " Shape: " + JSON.stringify(shape));

    const vis = () => ["p.array", {style: {border: "1px solid rgba(0,0,0,0.05)", display: "inline-flex", "align-items": "center", margin: "0.125rem"}},...arr.map(x => x.v(x))];

    return {r: read, s: save, i: info, store: () => arr, shape, v: vis};

};

const mapStore = (shape, vs = {}) => {

    if(!conform(shape,vs)) return;

    let map = !f.isEmpty(vs) ? f.kvmap((k,v) => ({[k]: makeStore(shape[k], v)}), vs) : f.kvmap((k,v) => ({[k]: makeStore(v)}), shape);

    const read = () => f.kvmap((k,v) => ({[k]: v.r()}), map);

    const save = (kvs) => {

	if(typeof kvs == "function") {

	    kvs = kvs(read());
	    
	}
	
    (map = f.kvmap((k,v) => ({[k]: makeStore(shape[k], v)}), kvs), read());

    };

    const vis = () => ["p.object",
		       {style: {"box-shadow": "0 4px 10px rgba(0,0,0,0.05)", padding: "1rem", "border-radius": "2px", display: "inline-block", margin: "0.25rem"}}, ...f.kvreduce((i,k,v) => (i.push(["p.pair", {style: {display: "flex"}},
								     ["p.key", {style: {"margin-right": "0.5rem"}}, k], v.v()]), i), [], map)];

    return {r: read, s: save, store: () => map, shape, v: vis};

};

const writer = (shape, tanmatra, storage) => {

    if(storage) {
	
	if(storage == "localStorage")
	    return (entity) => localStorage.setItem("tanmatra", JSON.stringify({shape, data: tanmatra.r(), storage}));

    }
    
};

const makeStore = (shape, v, {storage} = {}) => {

    let store = null;

    if(v != null) v = JSON.parse(JSON.stringify(v));

    if (typeof shape == "string") {

	shape = shape.toLowerCase();

	["number", "string", "boolean"].includes(shape);

	store = scalarStore(shape, v);

    } else if(shape instanceof Array) store = arrayStore(shape[0], v);

    else if(f.isObj(shape)) store = mapStore(shape, v);

    else console.error("Unknown shape: " + shape + " with values " + v);

    let w = storage ? writer(shape, store, storage) : () => console.error("No writer found");

    return f.merge(store, {w});

};

const tanmatra = ({storage = "memory", shape, load}, v) => {
    
    if(load != null) {

	if(storage == "localStorage") {

	    let entity = "tanmatra"; // Replace with queriedd entity later

	    let data = localStorage.getItem(load);

	    if(!data) { return null; }

	    else {

		try {

		    let {data: values} = JSON.parse(data);

		    return tanmatra(f.dissoc(JSON.parse(data), "data"), values);

		} catch (e) {

		    console.error("Couldn't parse data" + e);

		    return null;
		}

	    }

	};

    }

    else return queryParser(makeStore(shape, v, {storage}));

};

export {tanmatra}
