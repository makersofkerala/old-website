const localStore = (shape) => {

    let data = null;

    const create = (s = shape) => update(s);

    const read = () => JSON.parse(localStorage.getItem("state"));

    /* If not initialized, can't update */
    const update = (v) => {

	data = v;

	return data;

    };

    const save = (v) => {

	localStorage.setItem("state", JSON.stringify(data));

	return data;
	
    };

    const del = () => localStorage.removeItem("state");

    return {c: create, r: read, u: update, d: del};

};

const fileClientStore = (shape) => {

    let data = null;

    const create = (s = shape) => update(s);

    const read = async (shape) => {

	let result = await fetch("/t/", {method: "POST", query: shape});

	return result;
	
    };

    /* If not initialized, can't update */
    const update = (v) => {

	data = v;

	return data;

    };

    const save = (v) => {

	localStorage.setItem("state", JSON.stringify(data));

	return data;
	
    };

    const del = () => localStorage.removeItem("state");

    return {c: create, r: read, u: update, d: del};

};

const match = (tanmatra, queryEntity) => {

    const matchedEntity = tanmatra[queryEntity];

    if(matchedEntity) return matchedEntity;

    else console.log("No match found for: " + entity + " in " + JSON.stringify(entities));
    
};

const matcher = (tanmatra, method) => (entity, query, args) => {

    /* Special case when there's no entity specified */
    if(tanmatra instanceof Array && tanmatra[0] == "anonymous") {
	
	/* Happens when there's no entity but a plain store */
	let valOrFn = entity;

	return tanmatra[1][method](valOrFn);

    } else  {

	if(typeof entity == "string") {

	    return match(tanmatra, entity)[method](query, args);
	    
	} else {

	    console.log("Unimplemented");

	}
	
    }

};
/* 
const loadRef = async (ref) => {

    let {storage, entity} = ref;
    
    let result = (await loadRefVal(storage, entity));

    LOAD_DEBUG && console.log("[Load] Ref", result);

    return result;

};

const loadVal = async (store) => {

    LOAD_DEBUG && console.log("[Load] Value Store ", JSON.stringify(store));

    const {shape, data, collId} = store;

    if(scalars.includes(shape)) return {shape, data, collId};

    else if(f.isObj(shape)) return await loadMap(store);

    else console.error("Unknown value " + JSON.stringify(store));
    
};

// A collection of data
const loadColl = async (coll) => {

    LOAD_DEBUG && console.log("[Load] Array " + JSON.stringify(coll));

    let {shape, data, nextId, collId} = coll;

    console.log("Loading array with nextId", nextId);

    return {shape, data: await Promise.all(data.map(async x => {

        let {shape, data, collId} = await loadUnit(x);

        return {shape, data, collId};

    })), nextId, collId};

};

const loadMap = async (store) => {

    LOAD_DEBUG && console.log("[Load] Map " + JSON.stringify(store));
    
    let {shape, data, collId} = store;

    let mapData = (await Promise.all(Object.entries(data).map(async ([k,v]) => ({[k]: (await loadUnit(v))})))).reduce((i, m) => f.merge(i,m), {});

    return {shape, data: mapData, collId};

};


// There are three types of data
// A scalar store
// {@val: {shape: scalar,  data: scalarValue}}
// A collection
// {@coll: data}
// A named collection
// {@ref: key}
const loadUnit = async (data) => {

    LOAD_DEBUG && console.log("[Load] Data ", JSON.stringify(data));

    if(data["@val"]) return await loadVal(data["@val"]);

    else if(data["@coll"]) return await loadColl(data["@coll"]);

    else if(data["@ref"]) return await loadRef(data["@ref"]);

    else console.error("Unknown data to parse " + JSON.stringify(data));

};

const loadRefVal = async (storage, entity) => {

    let serializedData = await reader(storage)(entity);

    let parsedData = (serializedData != null) ? JSON.parse(serializedData) : null;

    if(parsedData) {

        let {shape, data, nextId, collId} = await loadUnit(parsedData);
    
        return {shape, data, nextId, collId};
        
        } else return null;

}

const loadEntity = async (storage, entity) => {

    LOAD_DEBUG && console.log("Loading entity: " + "tanmatra/" + entity);

    const refValue = await loadRefVal(storage, entity);

    if(refValue) {

	    let {shape, data, nextId, collId} = refValue;

	    return {data: {[entity]: data}, shape: {[entity + "@" + storage]: shape}, nextId, collId};
	
    } else return null;

};


*/