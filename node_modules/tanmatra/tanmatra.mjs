import { conform } from './conform.mjs';

import * as f from './fun.mjs';

const LOAD_DEBUG = false;

const CREATE_DEBUG = false;

const STORE_DEBUG = false;

const WRITE_DEBUG = false;

const COLL_DEBUG = false;

const genKey = (nextId = 0) => {

    let x = nextId;

    const counter = () => x++;

    return counter;
    
};

const scalars = ["number", "string", "boolean"];

const initVal = (shape) => ({"number": 0, "string": "", "boolean": false})[shape];

const arrayRef = (stores) => {

    const output = () => stores.map(s => s.o());

    const input = (...params) => stores.map(s => s.i(...params));

    const shape = ["any"];

    return {o: output, i: input, store: () => stores, shape};
    
};

const mapRef = (stores) => {

    const output = () => f.kvmap((k,v) => ({[k]: v.o()}), stores);

    const input = (...params) => f.kvmap((k,v) => ({[k]: v.i(...params)}), stores);

    const shape = "any";

    return {o: output, i: input, store: () => stores, shape};
    
};

const scalarStore = ({shape, data, entity, storage, collId}) => {

    conform(shape, data);

    STORE_DEBUG && console.log("[Init] scalar @" + entity + " with shape " + JSON.stringify(shape) + " with value " + JSON.stringify(data));

    const create = (val) => val != null ? val : initVal(shape);

    let val = create(data);

    STORE_DEBUG && console.log("[Created] scalar " + JSON.stringify(val) + " for entity " +  genEntityId(entity)  + " with " + (storage || "no") + " storage.");

    const output = () => val;

    const writeData = () => ({"@val": {shape, data: val, collId, entity}});

    const input = (valOrFn) => {

	    let value = valOrFn;

	    if(typeof valOrFn === "function") value = valOrFn(val);

	    val = create(value);

    };

    const vis = () => ["div" + (storage ? ".writeable" : ""), ["p", {class: "scalar " + typeof shape}, "" + val]];

    const write = async (mode) => {

        let data = writeData();

        await writeStore({entity, data, storage})(mode);

        return data;

    };

    const load = (entity, mode) => loadStore(entity)(mode);

    return f.merge({o: output, i: input, store: () => val, shape, v: vis, entity: () => entity, load, writeData}, storage ? {w: write} : {});

};

const writeStore = ({storage, entity, data}) => async (mode) => {

    storage = mode || storage;

    data = await data;

    const key = genEntityId(entity);

    WRITE_DEBUG && console.log("[Write] Entity: ", entity, "Data: ", data);

    await write(storage)({key, data});

    return {"@ref": {entity: key, storage}};

};

const writeOutput = async store => store.w ? await store.w() : await store.writeData();

const normalizeArrayShape = (sh) => f.isObj(sh) ? f.kvmap((k,v) => ({[k.split("@")[0]]: v}), sh) : sh;

const arrayStore = ({shape, data = [], storage, entity = [], nextId: seedId, collId}) => {

    CREATE_DEBUG && console.log("[Array / Create / Init] array store with values", data, "of shape", shape);

    conform(shape, data);

    COLL_DEBUG && console.log("Initailizing array store with seed " + seedId + " for " +  genEntityId(entity));

    let genId = genKey(seedId);

    let nextId = genId();

    COLL_DEBUG && console.log("Creating next id: " + nextId);

    let internalShape = shape[0];

    const nextItem = (item) => {

        // An array can have either a data element present or a {shape,data, collId} present inside it
        let { collId, data } = item;
    
        let itemId = null;

        if(collId == null) {

            COLL_DEBUG && console.warn("No Coll Id found for: " + JSON.stringify(item));

            itemId = nextId;

            nextId = genId();

        } else {

            COLL_DEBUG && console.info("Coll Id " + collId + " found : " + JSON.stringify(item));

            itemId = collId;

        }

        if(data != null) return ({shape: internalShape, data, entity: entity.concat(itemId), collId: itemId});

        else return ({shape: internalShape, data: item, entity: entity.concat(itemId), collId: itemId});

    };

    let arr = data.map(v => match(nextItem(v)));

    const output = () =>  arr.map(store => store.o());

    const writeData = async () => ({"@coll": {shape: [normalizeArrayShape(internalShape)], data: await Promise.all(arr.map(async store => await writeOutput(store))), nextId: nextId, collId, entity}});

    const inputValue = (params) => {
    
        // How can I ensure the collId remains intact?
    if(typeof params === "function") params = params(output());

	arr = params.map(data => match(nextItem(data)));

	return output();
	
    };

    const input = (query, params) => {

	if(params == null) return inputValue(query);
	
	else if(query != null) {

	    if(query === "push") push(params); 

	    if(query === "del") del(params);
	    
	} else {

	    console.error("Please pass in valid arguments for input" + JSON.stringify(query), JSON.stringify(params));
	    
	}

    };

    const push = v => {

	const s = match(nextItem(v)); 

	arr.push(s);

	return output();

    };

    const del = (idx) => (arr.splice(idx, 1), output()); 

    const vis = () => ["div" + (storage ? ".writeable" : ""), ["p.array",...arr.map(x => x.v(x))]]; 

    const write = async (mode) => await writeStore({entity, data: writeData(), storage})(mode);

    const load = async ({data, entity: savedEntity, collId: savedCollId, nextId: savedNextId}) => {

        collId = savedCollId;

        genId = genKey(savedNextId);

        nextId = genId();

        entity =  savedEntity;
        
        let stores = await Promise.all(data.map(async (storeData) => {

           let {shape, store, collId} = await loadStore(storeData);

           return store;

        }));

        LOAD_DEBUG && console.log("[Array / Create / Done] Entity: ", entity, "Store: ", stores);
        
        arr = stores;
        
    };

    return f.merge({i: input, o: output, store: () => arr, shape, v: vis, entity: () => entity, l: load, writeData}, storage ? {w: write} : {});

};

// Normalized shape gives back:
// {key: {shape, store}, key2: {shape, store}}
const normalizeShape = (shape) =>f.kvmap((k,v) => {

    let [childKey, storage] = k.split("@");

    return {[childKey]: {storage, shape: v}};

}, shape);

const mapStore = ({shape: mapShape, data = {}, storage, entity = [], nextId, collId} = {}) => {
    
    let normalShape = {};

    if(!f.isEmpty(mapShape)) {

    normalShape = mapShape == "any" ? "any" : normalizeShape(mapShape);

    conform(normalShape, data);

    };

    CREATE_DEBUG && console.log("[Map / Create / Init] map store Entity:", entity, "Shape: " + JSON.stringify(mapShape), "Values: ", JSON.stringify(data));

    // When loading a shape, shape could be {key: {shape, store}} or could alse be directly {key: {key ...}}
    const getKeyShape = (key) => {

	if(normalShape == "any")  return "any";

	let {shape: keyShape} = normalShape[key];

	return (keyShape.shape) ?  keyShape.shape : keyShape;

    };

    const getKeyStorage = (key) => normalShape ? (normalShape[key] && normalShape[key].storage) :  storage;

    const mapItem = ({key, data}) => {

       let mapItem = ({shape: getKeyShape(key), storage: getKeyStorage(key), entity: entity.concat(key), data, nextId, collId});

	CREATE_DEBUG && console.log("[Map / Create / Item] " + JSON.stringify(mapItem));

	return mapItem;

    };

    const buildMap = vs => {
	
	CREATE_DEBUG && console.log("[Map / Init / Values]", vs);

    return f.kvmap((key, data) => ({[key]: match(mapItem({key, data}))}), vs);

    };

    // The initial shape will be {shape: {key: {shape}, key: {shape}}}
    const initWithShapes = (mapShape) => {
	
	CREATE_DEBUG && console.log("[Map / Init / Shape]", mapShape);

	if(mapShape === "any") return {};
	
	else {

	return f.kvmap((key,_) => ({[key]: match(mapItem({key}))}), mapShape);
	    
	}

    };

    let map = f.isEmpty(data) ? initWithShapes(normalShape) : buildMap(data);

    CREATE_DEBUG && console.log("[Map / Created] Map store: ", JSON.stringify(map), " with data ", data);

    const output = () => {

	return f.kvmap((k,v) => ({[k]: v ? v.o() : console.error("Value not found!")}), map);

    };

    const writeData = async () => {
   
        let data = await promiseMap(async (k,v) => {

        WRITE_DEBUG && console.log("[Write] @",  k);

        let storage = getKeyStorage(k);

        let result = storage ? await writeStore({entity: v.entity(), storage, data: v.writeData()})(storage) :  await v.writeData();

        WRITE_DEBUG && console.log("Result is", result);
            
        return [k, result];

        }, map);

	console.log(normalShape);

        return {"@map": {shape: normalShape, data, collId, entity}};

    };

    // Make input have query and params. Also try unifying array and map
    const input = (kvs) => {

	if(typeof kvs === "function") kvs = kvs(output());
	
	map = buildMap(kvs);

	return output();

    };

    const vis = () => ["div" + (storage ? ".writeable" : ""),
		       entity ? ["p.entity", genEntityId(entity) || ""] : "",
		       ["p.object", ...f.kvreduce((i,k,v) => (i.push(["p.pair", ["p.key", k], ["p.value", v.v()]]), i), [], map)]];

    const write = async () => await writeData();

    const promiseMap = async (fn, map) => {

        return (await Promise.all(Object.entries(map).map(async ([k,v]) => {

            return await fn(k,v);

        }))).reduce((i, [k,v]) => Object.assign(i, {[k]: v}), {});

    };

    const loadShape = async () => await promiseMap(async (k,v) => {

            let [key, storage] = k.split("@");

            LOAD_DEBUG && console.log("[Map/Key Load]", "Key", key, "Storage", storage);

            if(storage) {

                let savedStore = await loadStore({"@ref": {entity: key, storage}});

                LOAD_DEBUG && console.log("[Load] Store Loaded.", savedStore);

                LOAD_DEBUG && (savedStore == null) && console.warn("[Load] No store to load. @" + key + " := " + JSON.stringify(map[key].o()) + " instead.");

                // LOAD_DEBUG && (savedStore != null) && console.log("%c [Load] Found store. @" + genEntityId(savedStore.store.entity()) + " := " + savedStore.store.o(), 'background: white; padding: 0.1rem; color: black');

                if(savedStore != null) return [key, savedStore.store];
                
                else return [key, map[key]];

            } else {

            LOAD_DEBUG && console.log("[Map / Load / Existing]", "Key", key, "Storage", storage);

                let existingStore = map[k];

                if(existingStore != null) return existingStore;

                else return [key, match({shape: v})];
            }

        }, mapShape);

    // A savedStore is {shape, store} pair
    const load = async ({store: savedStore, entity: savedEntity, storage: savedStorage, shape: savedShape} = {}) => {

	entity = savedEntity;

	let store = null;


	if(savedStore) {

	    LOAD_DEBUG && savedStore && console.log("[Map/Load] Saved Store", savedStore);

	    store = f.kvmap((k,v) => ({[k]: v.store}), savedStore);

	    normalShape = savedShape || savedStore.shape;

	} else {

	    store = await loadShape();

	}

	LOAD_DEBUG && console.log("[Map/Created] Entity: ", entity, "Store: ", store, "Shape:", JSON.stringify(mapShape));

	map = store;

    };

    // TODO : Evaluate if shape is needed
    return f.merge({i: input, o: output, store: () => map, shape: mapShape, v: vis, entity: () => entity, l: load, w: write, writeData});

};

const loadEntity = async ({entity, storage, url}) => {
    
    let ref = await loadRef({entity, storage, url});

    let store = tanmatra({});

    await store.l({store: {[entity]: ref}, entity});

    return store;

};


const loadVal = ({shape, data, entity, collId}) => {

    LOAD_DEBUG && console.log("[Load/Val] @", entity,  "Val: ", {shape, data, entity, collId});

    return {shape, store: scalarStore({shape, data, entity, collId})};
    
};

const loadUnit = async ({shape, data, entity, nextId, collId}) => {

        LOAD_DEBUG && console.log("[Load/Coll] @", genEntityId(entity),  "Val: ", {shape, data, entity, nextId, collId});

        let store = arrayStore({shape});

        await store.l({data, nextId, collId, entity});

        return {shape, store};
};

/* Output: {store, shape, collId} || null */
const loadMap = async ({shape, data, collId, entity}) => {

        const pairs = await Promise.all(Object.entries(data).map(async ([k,v]) => {

            let result = await loadStore(v);

            return ({[k]: result});

        }));

        const newMap = pairs.reduce((i, pair) => f.merge(i,pair), {});

        const store = mapStore({shape});

        await store.l({shape, store: newMap, entity});

        return {shape, store, collId};

};

/* Output: {store, shape, collId} || null */
const loadRef = async ({entity, storage, url}) => {

    LOAD_DEBUG && console.log("[Load/Ref]", {entity, storage, url});

    if(entity == null) throw Error("No Entity Specified!");

    if(storage == null) console.error("Please specify a reader for " + entity);

    const data = await reader({storage, url})(entity);

    let refUnit = (data != null) ? JSON.parse(data) : null;

    if(refUnit != null) return loadStore(refUnit, storage);

    else return null;

};

/* Output: {store, shape, collId} || null */
const loadStore = async (unit, storage) => {

    LOAD_DEBUG && console.log("[Load] Store", JSON.stringify(unit));

    if(unit["@val"] != null) return loadVal(unit["@val"]);

    else if(unit["@coll"] != null) return loadUnit(unit["@coll"]);

    else if(unit["@map"] != null) return loadMap(unit["@map"]);

    else if(unit["@ref"] != null) return loadRef(unit["@ref"]);

     else console.error("Unknown store");

};

// Can an array have a storage or is it a proxy to pass down storage from a top map store?

/* Querying */

const storeAtKey = (selection, k) => selection.store()[k];

const filter = (selection, fn) => {

    if(f.isArr(selection.shape)) return arrayRef(selection.store().filter(x => fn(x.o())));

    else if(f.isObj(selection.shape))  return mapRef(f.kvfilter((k,v) => fn(k, v.o()), selection.store()));

    else return fn(selection.o()) ? selection : null;
    
};

const selectObject = (store, q, preserveStructure = false) => {

    let queries = [];

    // Think this same approach can be used for arrays.
    // But see if the keys of the arrays and their ordinal property pose any challenges here.
    // May be a challenge would arise when iterating and the order contract changes. But verify this.
    const selections = f.kvreduce((i, k, v) => {

	queries.push(v);

	const selection = storeAtKey(store, k);

	if(selection) {

	    let innerSelection = null;

	    if(v === "?" || v === "v" || typeof v === "number" || typeof v === "function" || f.isArr(v) || f.isObj(v)) {

		innerSelection = processQuery(selection, v);
		
	    } else if(v === "k") {

		// Modifying this won't reflect on the store.
		innerSelection = scalarStore({shape: "string", data: k});

	    } else if(v === "kv") {
		
		let newSelection = processQuery(selection, "v");

		innerSelection = mapRef({[k]: newSelection});

	    } else throw Error("Unknown map value to query for " + JSON.stringify(v));

	    if(innerSelection) return preserveStructure ? f.merge(i, {[k]: innerSelection}) : f.concat(i, f.isArr(innerSelection.shape) ? innerSelection.store() : innerSelection);

	    else return i;

	} else return i;
	
    }, preserveStructure ? {} : [] , q);

    if(queries.length === 1 && !f.isArr(queries[0]) && typeof queries[0] != "function" && selections.length === 1) return selections[0];

    return preserveStructure ? mapRef(selections) : arrayRef(selections);
    
};

const selectArray = (store, qs) => {

    if(qs.length === 1 && f.isObj(qs[0])) qs = f.repeat(qs[0], store.store().length);

    let selections = f.mapidx((i, q) => {
	
	if(typeof q === "number") return storeAtKey(store, q);

	else {

	    // TODO: Pretty ad hoc change this.
	    let selection = processQuery(storeAtKey(store, i), q);

	    return selection ? selection : null;
	    
	}

    }, qs);

    selections = selections.filter(x => x != null && x.o() != null);

    return arrayRef(selections);

};

const processQuery = (selection, q) =>  {

    if(q === "?" || q === "v") return selection;

    else if(scalars.includes(typeof q)) return storeAtKey(selection,q);
    
    else if(typeof q === "function") return filter(selection, q);

    else if(f.isObj(q)) return selectObject(selection, q);

    else if(f.isArr(q)) return selectArray(selection, q);

    else throw Error("Unknown query " + JSON.stringify(q));

};

const processQueries = (selection, queries) => {

    if(f.isEmpty(queries)) return selectable(selection);

    let [q, ...others] = queries;

    if(typeof q === "string" && q.indexOf("/") != -1) {let queries = q.split("/"); q = queries[0]; others = queries.slice(1).concat(others);}

    let store = processQuery(selection, q);

    return store ? processQueries(store, others) : null;
    
};

const selectable = (store) => {

    let querySelector = (...queries) => processQueries(store, queries);

    Object.assign(querySelector, store);

    return querySelector;
    
};

const inferShape = ({shape, data, entity}) => {

    if(f.isArr(data)) return arrayStore({shape: ["any"], data, entity});

    else if(f.isObj(data)) return mapStore({shape: "any", data, entity});

    else return scalarStore({shape: "any", data, entity});
    
};

const genEntityId = (entity) => {

    if(!entity) return "No Key";

// Entities are formed as  notes/0/note
// Inorder to generate notes/0-note I have to make the prefix to a dash
    let [first, ...rest] = entity;

    let mid = null, last = null;

    if(rest.length > 1) {

        mid = rest.slice(0,-1);
        last = rest.slice(-1);

    } else if(rest.length == 1) {

        last = rest.slice(-1);

    } else {

        return first;

    }

    return first + "/" + (mid ? mid.map(x => typeof x == "number" ? x + "-" : x + "/") : []).join("") + last;

};

const match = (store) => {
    
    STORE_DEBUG && console.log("Matching ", store);

    if(typeof store.shape === "string") store.shape = store.shape.toLowerCase();

    if(store.shape === "any") return inferShape(store);

    if(scalars.includes(store.shape)) return scalarStore(store);
    
    else if(f.isArr(store.shape)) return arrayStore(store);

    else if(f.isObj(store.shape)) return mapStore(store);

    else console.error("Unknown store to match: " + JSON.stringify(store));

};

const tanmatra = (shape, data) => selectable(mapStore({shape, data}));

const makePOSTRequest = async (url, body) => {
    
    let [result, message] = [false, ""];

    try {

	const response = await fetch(url, {method: "POST", body});

	if(!response.ok) throw Error(result.status + " " + result.statusText);

	const responseData = await response.json();

	[result, message] = responseData;

    } catch(e) {

	result = false;

	message = e;
	
    };

    if(result) return [result, message];

    else console.error(message);

};

const loadJSON = async (url, entity) => {

    url = "/" + url;

    let body = JSON.stringify({mode: "load", data: entity});

    let [result, message] = await makePOSTRequest(url, body);

    return message;

};

const reader = ({url = "tanmatra/", storage}) => {

    if(storage === "localStorage") return entity => localStorage.getItem(url + entity);

    else if(storage === "file") return async entity => await loadJSON(url, entity);

    else if(storage === "disk") return async entity => {
	
	const backend = await import('./tanmatra-backend.mjs');

	const [_, result] = await backend.load({url, entity});

	return result;

    };

    else console.error("No reader for " + storage);

};

const write = storage => {

    if(storage === "localStorage") return localStorageWriter;

    else if(storage === "file") return dbWriter;

    else return x => x;

};

const localStorageWriter = ({key, data}) => localStorage.setItem("tanmatra/" + key, JSON.stringify(data));

const dbWriter = async ({key, data}) => {

    // TODO: Ability to specify arbitrary URL
    let url =  "/tanmatra/";

    let body = JSON.stringify({mode: "save", data: {key, data}});

    let [result, message] = await makePOSTRequest(url, body);

    return [result, message];

};

export {tanmatra, loadStore, loadRef, loadEntity};
