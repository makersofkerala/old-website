const anything = '*', oneOrMore = x => x + '+';
const charGroup = x => '[' + x + ']';
const group = x => '(' + x + ')';
const allowedURLChars = '\\w-_.', anyString = '\\s';
const lineStart = x => '^' + x, lineEnd = x => x + '$';
const entirely = s => lineEnd(lineStart(s));

const matcher = pattern => {
    
    // catch all after *
    pattern = pattern.replace(/\*.*/, "(.*)");

    let namedSegments = new RegExp(':' + group(oneOrMore(charGroup(lineStart(anyString + '/')))), 'g');
    
    let wordMatch = group(oneOrMore(charGroup(allowedURLChars)));
    
    let key_matches = pattern.match(namedSegments) || [];

    let keys = key_matches.map(x => x.slice(1));

    let matcher_pattern = new RegExp(entirely(pattern.replace(namedSegments, wordMatch)));

    return {regex: matcher_pattern, keys};

};

// match("/hello/:param", "/hello/there");
// => { string: '', keys: { param: 'there' } }

// match("/:hello/:param", "/hello/there");
// => { string: '', keys: { hello: 'hello', param: 'there' } }

// match("/hello/:there/*", "/hello/there/mate");
// => { string: 'mate', keys: { there: 'there' } }

// match("/*", "/")
// => { string: '', keys: {} }

const match = (pattern, url) => {

    let {keys, regex} = matcher(pattern);

    let match = url.match(regex);

    if(Array.isArray(match)) {
	
    if(match.length > 1) {
	
	let vals = match.slice(1);
	
	let matchPairs = {};

	for(let i = 0; i < keys.length; i++) {
	    
	    Object.assign(matchPairs, {[keys[i]]: vals[i]});
	    
	}

	let remaining = vals.slice(keys.length);

	return {string: remaining.length > 0 ? remaining[0] : "", keys: matchPairs};

    } else if(match.length == 1) {

	return {string: match[0], keys: {}};
	
    }
    } else {
	
	return null;
    }
    
};

export { matcher, match };
